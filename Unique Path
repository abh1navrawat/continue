There is a robot on an m x n grid. The robot is initially located at the top-left corner (i.e., grid[0][0]). The robot tries to move to the bottom-right corner (i.e., grid[m - 1][n - 1]). The robot can only move either down or right at any point in time.

Given the two integers m and n, return the number of possible unique paths that the robot can take to reach the bottom-right corner.

The test cases are generated so that the answer will be less than or equal to 2 * 109.





intuition - Make the m*n grid to 2*n grid representing the values for current and previous row.We can just overwrite the previous row and use the current row as the previous row in the nezt iteration.
            & operator is used for alternating between rows.





class Solution:
    def uniquePaths(self, m, n):
        dp = [[1]*n for i in range(2)]
        for i in range(1,m):
            for j in range(1,n):
                dp[i&1][j] = dp[(i-1)&1][j] + dp[i&1][j-1]
        return dp[(m-1)&1][-1]





intuition - If we can only move right and down then each cell value is the sum of the paths coming from the cell above and the cell to the left

            For example, 3x3 grid.

            1   1   1
            1   2   3
            1   3   6

            Set the first row of 1s only because only 1 way to reach. after that change the value of the cell by calculating the sum of left and above cell. Return the last value.




class Solution:
    def uniquePaths(self, m: int, n: int) -> int:
        
        aboveRow = [1] * n

        for i in range(m - 1):
            currentRow = [1] * n
            for j in range(1, n):
                currentRow[j] = currentRow[j-1] + aboveRow[j]
            aboveRow = currentRow
        
        return aboveRow[-1]
