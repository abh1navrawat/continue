You are given an integer array heights representing the heights of buildings, some bricks, and some ladders.

You start your journey from building 0 and move to the next building by possibly using bricks or ladders.

While moving from building i to building i+1 (0-indexed),

If the current building's height is greater than or equal to the next building's height, you do not need a ladder or bricks.
If the current building's height is less than the next building's height, you can either use one ladder or (h[i+1] - h[i]) bricks.
Return the furthest building index (0-indexed) you can reach if you use the given ladders and bricks optimally.






intuition - big is the heap queue. This queue is  max heap that means the largest element is at the top(comes first). diff tells how many bricks are needed to cross the building. If its negative or zero skip
            that building. Subtract diff from total no. of bricks, and add that diff value to big heapq(insert it in negative form, so that the biggest value become smallest(max heap)). If the bricks become
            negative, pop the biggest value from heapq(inverting it to positive) and add it to bricks and reduce the amount of ladders by 1. When the ladders become negative then break the loop.
            If the loop is completed the all buildings can be crossed and return the len of the height array - 1(we are already on the 1st building).






class Solution:
    def furthestBuilding(self, heights: List[int], bricks: int, ladders: int) -> int:
        big=[]
        
        for i in range(len(heights)-1):
            diff=(heights[i+1] - heights[i])

            if diff < 1:
                continue
            
            bricks-=diff
            heapq.heappush(big,-diff)

            if bricks<0:
                bricks+= -heapq.heappop(big)
                ladders-=1

            if ladders<0:
                return i
        return len(heights)-1
