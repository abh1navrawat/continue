You are given an array nums of size n, consisting of non-negative integers. Your task is to apply some (possibly zero) operations on the array so that all elements become 0.

In one operation, you can select a subarray [i, j] (where 0 <= i <= j < n) and set all occurrences of the minimum non-negative integer in that subarray to 0.

Return the minimum number of operations required to make all elements in the array 0.



intuition - Have to convert the array to a monotonic stack (stack that either increase or decrease) that strictly increase. We will pop the element if the stack[top] is greater than num and increment the ans
            if stack[top] is not equal to num then change the stack[top] to num (this will help in avoiding duplicates). Atlast return the ans + top ( top  gives the non-redundant values).

class Solution:
    def minOperations(self, nums):
        stack = [0] * (len(nums) + 1)
        top = 0
        ans = 0
        for num in nums:
            while stack[top] > num:
                top -= 1
                ans += 1
            if stack[top] != num:
                top += 1
                stack[top] = num
        return ans + top
