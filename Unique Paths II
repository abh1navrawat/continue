You are given an m x n integer array grid. There is a robot initially located at the top-left corner (i.e., grid[0][0]). The robot tries to move to the bottom-right corner (i.e., grid[m - 1][n - 1]). The robot can only move either down or right at any point in time.

An obstacle and space are marked as 1 or 0 respectively in grid. A path that the robot takes cannot include any square that is an obstacle.

Return the number of possible unique paths that the robot can take to reach the bottom-right corner.

The testcases are generated so that the answer will be less than or equal to 2 * 109.





intuition - we will convert the 2d array to 2 1d array(by making use of current and previous row). 1st value of previus will be 1 because there is only 1 way to reach it.Now we will start iterating through 
            the grid. If it is an obstacle then that block is unreachable put 0 in place of that current value otherwise  the number of ways to reach the cell is the sum of the ways to reach the cell above 
            and the cell to the left. For the first value of current you cannot use the previous current values so,just check if it is an obstacle make it 0 otherwise 1st value of previous.
            Once we've processed a row, we set previous to current, preparing for the next iteration(previous will represent the last row).Atlast previous[n-1] tells all the path to reach bottom right block.





class Solution:
    def uniquePathsWithObstacles(self, obstacleGrid: List[List[int]]) -> int:
        
        m, n = len(obstacleGrid), len(obstacleGrid[0])
        
        previous = current = [0] * n
        previous[0] = 1
        
        for i in range(m):
            current[0] = 0 if obstacleGrid[i][0] == 1 else previous[0]
            for j in range(1, n):
                current[j] = 0 if obstacleGrid[i][j] == 1 else current[j-1] + previous[j]
            previous = current
        return previous[n-1]





intuition - Cannot use   res=[[0]*len(z[0])]*len(z)  This doesnâ€™t create independent rows. It creates multiple references to the same list. So when you change res[i][0], it updates all rows simultaneously
            Python reuses the same list reference when you use *. Thats why need to use comprehension because iteration create different memory addresses.

            Unlke above solution, we are just putting 1 in the 1st row and 1st column of res (only 1 way to reach) if the there are any obstacle break the loop.
            Now same as the above solution, just add the left and above value. Return the last element. 
            if obstacleGrid==[[0]] condition is for the last testcase. if obstacleGrid[0][0]==1 is when the 1st path is blocked then return 0 because we cannot advance from there on.





class Solution:
    def uniquePathsWithObstacles(self, obstacleGrid: List[List[int]]) -> int:
        if obstacleGrid[0][0]==1:
            return 0

        if obstacleGrid==[[0]]:
            return 1
        res = [[0]*len(obstacleGrid[0]) for _ in range(len(obstacleGrid))]

        m,n=len(obstacleGrid),len(obstacleGrid[0])

        for i in range(1,n):
            if obstacleGrid[0][i]==1:    
                break
            res[0][i]=1

        for i in range(1,m):
            if obstacleGrid[i][0]==1:
                res[i][0]=0
                break
            res[i][0]=1
        
        for i in range(1,m):
            for j in range(1,n):
                if obstacleGrid[i][j]==1:
                    res[i][j]=0
                    continue
                res[i][j]=res[i-1][j]+res[i][j-1]
        return res[-1][-1]
                
